/*
题目描述：
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
*/

/*
思路：
我们先看一下数字的下一个数，“12999”→“13000”.可以看出有两部分操作：高位“进一”，低位“置零”。而在此之前还要寻找到高低位的分界线。
这题类似，可通过这三步得到下一个更大的排列，以【1，2，4，3，1】为例：
1.寻找到高低位的分界线
这一步即寻找到最低的高位，使得它后面的数排列最大。而降序排列是最大的一个排列，因此从低位往高位找第一个非逆序数的下标即可。
那么下标1是我们所找到的高位
2.高位进一
低位排列中寻找最小的、比高位数大的数，与高位数交换即可。（由于低位已是降序，因此从低到高遍历，第一个大于高位数的即是我们所要找的）
这里找到下标3是我们要找的，【1，2，4，3，1】→ 【1，3，4，2，1】
3.低位置零
将低位排列成最小排列。由于原本已是降序排列，因此逆序后即可得到最小排列
只看低位：【4，2，1】→ 【1，2，4】
最后结果即为：【1，3，1，2，4】

时间复杂度:O(n)
空间复杂度:O(1)
*/

class Solution {
   	    public void nextPermutation(int[] nums) {
          	int i = nums.length - 1;
	        for(; i > 0; i--){
	            //nums[i:]为逆序数组,找到最小的i
	            if(nums[i] > nums[i - 1]){
	                int k = nums.length - 1;//第一个大于nums[i - 1]的数的下标
	                while(k > i - 1 && nums[k] <= nums[i - 1]) {
	                	k--;
	                }
	                exchange(nums, i - 1, k);
                    break;
	            }
	        }
	        reverse(nums, i, nums.length - 1);
	    }
	    
	    public void exchange(int[] nums, int i, int j){
	        int temp = nums[i];
	        nums[i] = nums[j];
	        nums[j] = temp;
	    }
	    //将降序数组反转成升序
	    public void reverse(int[] nums, int i, int j){
	        while(i < j){
	            exchange(nums, i++, j--);
	        }
	    }
	}
